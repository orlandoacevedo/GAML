from GAML.functions import file_gen_new, file_size_check
from GAML.function_gen_range import func_gen_range


class Charge_gen_range(object):
    """Generate the charge ranges surrounding the mode number"""
    def __init__(self,*args,**kwargs):
        if 'atomnm' in kwargs and kwargs['atomnm'] is not None:
            try:
                self.atomnm = int(kwargs['atomnm'])
                if self.atomnm <= 0:
                    raise ValueError
            except ValueError:
                raise ValueError('atomnm has to be a positive integer')
        else:
            raise ValueError('atomnm is missing')

        if 'charge_path' in kwargs and kwargs['charge_path'] is not None:
            self.pro_chargepath(kwargs['charge_path'])
        else:
            raise ValueError('charge_path is missing')

        if 'percent' in kwargs and kwargs['percent'] is not None:
            try:
                self.percent = float(kwargs['percent'])
                if self.percent > 1.0 or self.percent <= 0:
                    raise ValueError
            except ValueError:
                raise ValueError('percent has to be a positive, within (0,1)')
        else:
            self.percent = 0.8

        if 'stepsize' in kwargs and kwargs['stepsize'] is not None:
            try:
                self.stepsize = float(kwargs['stepsize'])
                if self.stepsize <= 0:
                    raise ValueError
            except ValueError:
                raise ValueError('stepsize has to be positive number')
        else:
            self.stepsize = 0.01

        if 'nmround' in kwargs and kwargs['nmround'] is not None:
            try:
                self.nmround = int(kwargs['nmround'])
                if self.nmround < 0:
                    raise ValueError
            except ValueError:
                raise ValueError('nmround has to be positive number')
        else:
            self.nmround = 3

        if 'fname' in kwargs and kwargs['fname'] is not None:
            self.fname = str(kwargs['fname']).strip()
        else:
            self.fname = 'ChargeGenRange'



    def pro_chargepath(self,file):
        """parse charge_path

        Here may have bugs if the input is not generated by the Gaussian.

        Formats:

            nm  atomtype    charge
            1     C           0.1
            2     H           0.2
            3     O          -0.2

            Only three columns are used.
                1st :   input index
                2nd :   atom type   (ignored)
                3rd :   value

            Otherwise,
                Warning will be printed
        """
        self.charge_path = file
        file_size_check(self.charge_path,fsize=100)

        datalist = []
        with open(self.charge_path,mode='rt') as f:
            while True:
                line = f.readline()
                if len(line) == 0:
                    break

                sub = line[:line.find('#')] if line.find('#') != -1 else line
                lst = sub.split()
                if len(lst) == 0: continue

                if len(lst) == 3:
                    try:
                        n = int(lst[0])
                        v = float(lst[2])
                    except ValueError:
                        print(line)
                        raise ValueError('wrong defined line')
                    if n <= self.atomnm:
                        datalist.append(v)
                else:
                    print('Warning: ignoring ' + line)

        if len(datalist) % self.atomnm != 0:
            raise ValueError('not corresponded: atomnm & charge_path')

        # to avoid using an extra numpy module
        # works similar like;
        # numpy.array(datalist).reshape(len(datalist)//self.atomnm,self.atomnm)
        self.profile = []
        i = 0
        while i < len(datalist):
            ls = []
            for j in range(self.atomnm):
                ls.append(datalist[i])
                i += 1
            self.profile.append(ls)



    def run(self):
        atom = 0
        self.charge_range = []
        while atom < self.atomnm:
            atomcharge = []
            for mol in self.profile:
                atomcharge.append(mol[atom])

            lmin = charmin = min(atomcharge)
            lmax = max(atomcharge)

            rlist = []
            while lmin < lmax:
                lcount = 0
                # Warning! to improve the efficiency, here can be debugged
                for i in atomcharge:
                    if i < lmin + self.stepsize and i >= lmin:
                        lcount += 1
                rlist.append(lcount)
                lmin += self.stepsize

            ndxmin, ndxmax = func_gen_range(rlist,percent=self.percent)

            v1 = round((ndxmin*self.stepsize+charmin), self.nmround)
            v2 = round(((ndxmax-1)*self.stepsize+charmin), self.nmround)
            self.charge_range.append([v1,v2])

            atom += 1



    def file_print(self):
        fname = file_gen_new(self.fname,fextend='txt',foriginal=True)
        print('Note: new file: < {:} >'.format(fname))
        with open(fname,mode='wt') as f:
            f.write('# File charge ranges based on the input charge_file \n')
            f.write('# The charge file used is:\n')
            f.write('#     {:s}\n'.format(self.charge_path))
            f.write('# Line is corresponded to each atom \n\n')
            j = 1
            for i in self.charge_range:
                f.write('ATOM {:>6d} {:>11.4f} {:>11.4f}\n'.format(j,i[0],i[1]))
                j += 1



