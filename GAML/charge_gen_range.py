from GAML.functions import file_gen_new, file_size_check
from GAML.function_gen_range import function_gen_range

class Charge_gen_range(object):
    """Generate the charge ranges surrounding the mode number"""   

    def __init__(self,charge_path,atomnm,**kwargs):
        try:
            self.atomnm = int(atomnm)
            if self.atomnm <= 0:
                raise ValueError
        except:
            print('Error: the parameter atomnm has to be a positive integer')
            exit()
            
        self.charge_path = charge_path
        
        if 'percent' in kwargs:
            if kwargs['percent'] is None:
                self.percent = 0.8
            else:
                try:
                    self.percent = float(kwargs['percent'])
                    if self.percent > 1.0 or self.percent <= 0:
                        raise ValueError
                except:
                    print('Error: the parameter percent has to be a positive number')
                    print('     : and its value must fall within in (0,1]')
                    exit()                
        else:
            self.percent = 0.8
            
            
        if 'stepsize' in kwargs:
            if kwargs['stepsize'] is None:
                self.stepsize = 0.01
            else:
                try:
                    self.stepsize = float(kwargs['stepsize'])
                    if self.stepsize <= 0:
                        raise ValueError
                except:
                    print('Error: the parameter stepsize has to be a positive number')
                    exit()            
        else:
            self.stepsize = 0.01

            
        if 'nmround' in kwargs:
            if kwargs['nmround'] is None:
                self.nmround = 3
            else:
                try:
                    self.nmround = int(kwargs['nmround'])
                    if self.nmround < 0:
                        raise ValueError
                except:
                    print('Error: the parameter nmround has to be a positive integer')
                    exit()
        else:
            self.nmround = 3

            
        if 'fname' in kwargs:
            if kwargs['fname'] is None:
                self.fname = 'ChargeGenRange'
            else:
                self.fname = str(kwargs['fname'])
        else:
            self.fname = 'ChargeGenRange'

         
    def file_process(self):
        """ATTENTION! Here may have bugs, if the input charge_file_path is not
           generated by the Gaussian. The follow shows the file format:

           nm  atomtype    charge
           1     C           0.1
           2     H           0.2
           3     O          -0.2

           Only three columns are used. The first column is the input index,
           the second column is the atom-type, the last one is the value"""
        
        dump_value = file_size_check(self.charge_path,fsize=100)
        
        datalist = []
        with open(self.charge_path,mode='rt') as f:
            while True:
                line = f.readline()
                if len(line) == 0:
                    break
                else:
                    lst = line[:line.find('#')].split()
                    if len(lst) == 3 and int(lst[0]) <= self.atomnm:
                        datalist.append(float(lst[2]))

        if len(datalist) % self.atomnm != 0:
            print('Error: wrong input_data_file or atom_number')
            print('Error: input charge_file_path: ',self.charge_path)
            print('Error input atom_number: ',self.atomnm)
            exit()


        # to avoid using an extra numpy module
        # works similar like;
        #     numpy.array(datalist).reshape(len(datalist)//self.atomnm,self.atomnm)
        
        pro_datalist = []
        i = 0
        while i < len(datalist):
            ls = []
            j = 0
            while j < self.atomnm:
                ls.append(datalist[i])
                i += 1
                j += 1
            pro_datalist.append(ls)

        return pro_datalist


    def charge_range(self):
        
        datalist = self.file_process()        
                                     
        atom = 0
        charge_range = []
        while atom < self.atomnm:
            atomcharge = []
            for mol in datalist:
                atomcharge.append(mol[atom])

            lmin = charmin = min(atomcharge)
            lmax = max(atomcharge)
            
            rlist = []
            while lmin < lmax:          
                lcount = 0
                # Warning! to improve the efficiency, here can be debugged
                for i in atomcharge:
                    if i < lmin + self.stepsize and i >= lmin:
                        lcount += 1
                rlist.append(lcount)
                lmin += self.stepsize

            ndxmin,ndxmax = function_gen_range(rlist,percent=self.percent)

            ltmp = []
            ltmp.append(round((ndxmin * self.stepsize + charmin),self.nmround))
            ltmp.append(round(((ndxmax-1) * self.stepsize + charmin),self.nmround))
            charge_range.append(ltmp)

            atom += 1

        return charge_range


    def file_print(self):
        
        fname = file_gen_new(self.fname,fextend='txt',foriginal=True)

        charge_range = self.charge_range()
        
        with open(fname,mode='wt') as f:
            f.write('# This is the generated charge_range based on the input charge_file \n')
            f.write('# The charge file used is:\n')
            f.write('#     {:s}\n'.format(self.charge_path))
            f.write('# Each line\'s charge_range is corresponded to each atom \n\n')
            j = 1
            for i in charge_range:
                f.write('ATOM {:>6d}    {:>8.4f}    {:>8.4f}\n'.format(j,i[0],i[1]))
                j += 1

        return 1

